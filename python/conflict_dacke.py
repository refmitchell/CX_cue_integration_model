"""
conflict_dacke.py

Simulates the cue conflict paradigm from Dacke et al. (2019).

Dacke et al. (2019) test three scenarios, each performs the
same cue manipulation but with the sun at high, medium, and low
elevations. Dacke et al. (2019) use ranges to determine high, medium,
and low, so we take the midpoint of that range for our test. Thus
windspeed is 3m/s and elevations will be 22.5, 52.5, and 82.5 degrees
for low, medium, and high respectively.

In order to approximate kappa values we will use the estimation functions
provided by Shaverdian et al. (2022).

[Legacy] - This was excluded as we did not have any reasonable way
to estimate the strength or reliability of a wind cue with 3 m/s
wind speed. The data from Shaverdian et al. (2022) was more comprehensive
so we decided to focus on that experiment (conflict_shav.py).

References:
Dacke et al. (2019) - Multimodal cue integration in the dung beetle
                      compass, PNAS
Shaverdian et al. (2022) - Weighted cue integration for straight-line
                           orientation, iScience
"""

import json
import numpy as np
import dict_key_definitions as keydefs
from extended_ring_model import *
from dict_key_definitions import rmkeys, decodekeys, simkeys, statskeys, simdatakeys, dackeparams
from dict_key_definitions import conflict_weight_reskeys as reskeys
import simulation_utilities as simutils
from test_utilities import angular_difference, circ_scatter, kappa

exp_params = dict()
exp_params[dackeparams.high] = (82.5, 3) # (elevation, windspeed)
exp_params[dackeparams.mid] = (45, 3)
exp_params[dackeparams.low] = (22.5, 3)

def wind_kappa_estimator(speed, c_wind=0.133):
    """
    Given a wind speed in m/s, this function returns the concentration
    parameter of the noise distribution generated by that wind speed.
    This function is taken directly from Shaverdian et al. (2022).
    As such this estimation is not entirely appropriate for this data as
    the wind setup used was different for Dacke et al. (2019), however,
    there are no other options for estimating this parameter.
    """
    r = 0.11*speed + 0.43 + c_wind
    print("R wind = {}".format(r))
    return kappa(r)

def solar_kappa_estimator(elevation, c_sun=0.135):
    """
    Given a solar elevation in degrees, this function returns the concentration
    parameter of the noise distribution generated by that solar elevation.
    This function is taken directly from Shaverdian et al. (2022).
    Similarly to the wind estimator, this is not really appropriate for this data
    as Dacke et al. (2019) used a natural sun and did not hide other potential
    cues from the beetles. Again, there are no other options for estimating this
    parameter.
    """
    r = -0.07 * elevation + 0.8 if elevation <= np.radians(75) else -1.26 * elevation + 2.31
    r += c_sun
    print("R solar = {}".format(r))
    return kappa(r)

if __name__ == "__main__":
    # Init random generators
    s1 = np.random.randint(0, high=100000000)
    s2 = np.random.randint(0, high=100000000)

    s1 = 73866205
    s2 = 87415498

    print(s1)
    print(s2)

    sm_seed = 5437958
    placement_seed = 98437535
    desired_seed = 345702

    for exp in exp_params.keys():
        gen1 = np.random.RandomState(s1)
        gen2 = np.random.RandomState(s2)
        sm_gen = np.random.RandomState(sm_seed)
        placement_gen = np.random.RandomState(placement_seed)
        desired_gen = np.random.RandomState(desired_seed)

        # Local simulation parameters
        n = 40

        print(exp)
        k1 = solar_kappa_estimator(np.radians(exp_params[exp][0]))
        k2 = wind_kappa_estimator(exp_params[exp][1])

        # Assume that under natural(ish) conditions strength is correlated with
        # reliability
        w1 = k1 / (k1 + k2)
        w2 = 1 - w1

        print(k1)
        print(k2)

        params = simutils.default_param_dict.copy()

        params[simkeys.cue_one_noise_gen] = gen1
        params[simkeys.cue_two_noise_gen] = gen2
        params[simkeys.sm_noise_gen] = sm_gen
        params[simkeys.placement_gen] = placement_gen
        params[simkeys.desired_direction_gen] = desired_gen
        params[simkeys.sm_noise] = True
        params[simkeys.k1] = k1
        params[simkeys.k2] = k2
        params[simkeys.s1] = s1
        params[simkeys.s2] = s2
        params[simkeys.w1] = w1
        params[simkeys.w2] = w2
        params[simkeys.sm_seed] = sm_seed
        params[simkeys.placement_angle_seed] = placement_seed
        params[simkeys.desired_angle_seed] = desired_seed

        data = dict()
        stats = dict()
        snapshots = dict()

        agents = simutils.initialise(n)

        # Phase 1: initial rolls
        params[simkeys.n_rolls] = 2
        params[simkeys.flatten_on_first] = True # Clear any previous snapshots
        params[simkeys.c2_offset] = 90 # Dacke et al. present the wind at 90deg
        simdata = simutils.perform_runs(agents, params)
        data[reskeys.phase1] = simdata[simdatakeys.world] # Orientation data
        snapshots[reskeys.phase1] = simdata[simdatakeys.snapshots] # Snapshots
        sns = snapshots[reskeys.phase1][0]

        desired_directions = []
        for individual in simdata[simdatakeys.world]:
            desired_directions.append(individual[0][0][4])

        # Phase 2: pre-conflict roll
        params[simkeys.flatten_on_first] = False # Allow snapshots to persist
        params[simkeys.n_rolls] = 1
        params[simkeys.desired] = desired_directions
        simdata = simutils.perform_runs(agents, params)
        data[reskeys.phase2] = simdata[simdatakeys.world] # Orientation data
        snapshots[reskeys.phase2] = simdata[simdatakeys.snapshots] # Snapshots

        # Phase 3: conflict roll
        params[simkeys.c2_offset] = -90 # 180deg conflict
        simdata = simutils.perform_runs(agents, params)
        data[reskeys.phase3] = simdata[simdatakeys.world] # Orientation data
        snapshots[reskeys.phase3] = simdata[simdatakeys.snapshots] # Snapshots

        # Phase 4: controll roll (cues re-aligned)
        params[simkeys.c2_offset] = 90 # Back to original position
        simdata = simutils.perform_runs(agents, params)
        data[reskeys.phase4] = simdata[simdatakeys.world] # Orientation data
        snapshots[reskeys.phase4] = simdata[simdatakeys.snapshots] # Snapshots

        print("Computing stats for {}".format(exp))

        for key in data.keys():
            stats[key] = simutils.summary_statistics(
                data[key],
                arena_size=params[simkeys.arena_size],
                step_size=params[simkeys.step_size]
            )

        # Write results
        # Simulation metadata (parameters). Note that w1, w2, and flatten_on_first
        # will all be meaningless here. Generators are removed as they are not
        # serializable and the important parameter is the seed used.
        with open("data_out/conflict_dacke_{}.json".format(exp), "w") as f:
            del params[simkeys.cue_one_noise_gen]
            del params[simkeys.cue_two_noise_gen]
            del params[simkeys.sm_noise_gen]
            del params[simkeys.placement_gen]
            del params[simkeys.desired_direction_gen]
            json.dump(params, f)

        # Simulation data (can be used for constructing tracks)
        with open("data_out/conflict_dacke_{}.json".format(exp), "w") as f:
            json.dump(data, f)

        # Simulation summary statistics.
        with open("data_out/conflict_dacke_{}.json".format(exp), "w") as f:
            json.dump(stats, f)
