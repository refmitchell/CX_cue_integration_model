"""
strength_model.py

Here we define our strength model used in conflict experiments. Function
naming is not consistent with the terminology used in the paper. The
relative_strength() function is the primary mode of interaction and
this will specify the relative *weight* of a light cue given an
elevation. If 'shav' option is specified then relative_strength()
will return relative *weight* specified by the adjusted reliability
model from Shaverdian et al. (2022).

The functions here are designed to be imported by other modules. If this
module is run directly it will generate the strengh model figure from the
paper.
"""

import numpy as np
import matplotlib.pyplot as plt
from test_utilities import kappa
import argparse

def sigmoid(x, a=53):
    return 1 / (1 + np.exp(-a*(x - 0.5)))

def wind_kappa_estimator(speed, c_wind=0.133):
    """
    Given a wind speed in m/s, this function returns the concentration
    parameter of the noise distribution generated by that wind speed.
    This function is taken directly from Shaverdian et al. (2022).
    """
    # Full precision
    wp = [0.10535196693604602, 0.4320428569839185]
    r = wp[0]*speed + wp[1] + c_wind

    return (kappa(r), r)

def solar_kappa_estimator(elevation, c_sun=0.135):
    """
    Given a solar elevation in degrees, this function returns the concentration
    parameter of the noise distribution generated by that solar elevation.
    This function is taken directly from Shaverdian et al. (2022).
    """

    # Full precision
    llp = [-0.07160132557593242, 0.7652768340837904]
    ulp = [-1.2606411908208124, 2.3191740839514146]

    # Split-linear (Shaverdian et al. 2022)
    r = np.where(
        elevation <= np.radians(75),
        llp[0] * elevation + llp[1],
        ulp[0] * elevation + ulp[1]
    )

    r += c_sun
    return (kappa(r), r)

def light_strength_model(phis, scale=1, shav=False):
    """
    Given a series of light elevations, compute light strength
    based on a simple vector projection model.
    """
    phis = np.array(phis)
    if shav:
        if phis.shape == ():
            return solar_kappa_estimator(phis)[0]
        return np.array([solar_kappa_estimator(p)[0] for p in phis])

    return scale*np.cos(phis)

def wind_strength_model(speeds, a=0.3, fixed=0.5, shav=False):
    """
    Linear strength model for wind which passes through (2.5,fixed).
    """
    speeds = np.array(speeds)
    if shav:
        if speeds.shape == ():
            return wind_kappa_estimator(speeds)[0]
        return np.array([wind_kappa_estimator(s)[0] for s in speeds ])
    return a * speeds + (fixed - a*2.5)

def relative_strength(phi, speed, shav=False):
    """
    Returns the realtive strength of the light cue given an elevation and
    wind speed. The strength of the wind is assumed to be 1 - rls.
    """
    ls = light_strength_model(phi, shav=shav)
    ws = wind_strength_model(speed, shav=shav)
    rls = ls / (ws + ls)
    if shav:
        return sigmoid(rls, a=53) # Same adjustment as in Shaverdian et al. (2022)
    return rls

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-s",
                        "--shaverdian2022",
                        action="store_true",
                        required=False,
                        help="Plot kappa estimation from Shaverdian et al. (2022)")
    args = parser.parse_args()
    # Use the kappa estimation and adjustment from Shaverdian et al. (2022) to
    # generate the strength model. For plotting, everything is computed anyway
    # this option just toggles the plot format.
    shav=args.shaverdian2022

    # Generate strength models for each cue type
    n = 100
    elevations = np.linspace(0, np.pi/2, n)
    speeds = np.linspace(1.25, 2.5, n)

    # Basic strength/weight model
    light_strengths = light_strength_model(elevations, scale=1,shav=False)
    wind_strengths = wind_strength_model(speeds, shav=False)

    # Shaverdian strength/weight model
    shav_ls = light_strength_model(elevations, scale=1, shav=True)
    shav_ws = wind_strength_model(speeds, shav=True)

    # Compute their relative strengths for each combination
    es, ss = np.meshgrid(elevations, speeds)

    zs = relative_strength(es,ss,shav=False)
    shav_zs = relative_strength(es,ss,shav=True)

    # Plotting
    mosaic = [["light", "combination", "wind"]]

    size = (8,3)
    if shav:
        mosaic.append(["sl", "sc", "sw"])
        size=(8,5)

    fig, axs = plt.subplot_mosaic(mosaic, figsize=size)

    axs["light"].plot(elevations,
                      light_strengths,
                      color="tab:red",
                      linewidth=2)

    # Plot light model
    axs["light"].set_xlim([-0.02, np.pi/2 + 0.02])
    axs["light"].set_ylim([-0.01, 1.01])
    axs["light"].set_yticks([0, 1], labels=["0", "1"])
    axs["light"].set_xticks([0, np.pi/2], labels=[r"$0^\degree$", r"$90^\degree$"])
    axs["light"].set_title("Light strength model")
    axs["light"].set_xlabel(r"Light elevation - $\phi$")
    axs["light"].set_ylabel(r"Strength - cos$(\phi)$")

    # Plot wind model
    axs["wind"].plot(speeds,
                     wind_strengths,
                     color="tab:blue",
                     linewidth=2
    )
    axs["wind"].set_xlim([1.23, 2.52])
    axs["wind"].set_ylim([-0.01, 1.01])
    axs["wind"].set_yticks([0, 1], labels=["0", "1"])
    axs["wind"].set_xticks([1.25, 2.5], labels=["1.25", "2.5"])
    axs["wind"].set_title("Wind strength model")
    axs["wind"].set_xlabel(r"Wind speed (m/s) - $s$")
    axs["wind"].set_ylabel(r"Strength - $a(s) + (\frac{1}{2} - a(2.5))$")


    # Plot combination
    wmap = axs["combination"].pcolormesh(
        es, ss, zs, vmax=1, vmin=0, cmap="RdBu_r")
    wmap.set_edgecolor('face')

    axs["combination"].set_xlabel("Light elevation - $\phi$")
    axs["combination"].set_ylabel("Wind speed (m/s)")
    axs["combination"].set_xticks([0, np.pi/4, np.radians(60), np.radians(75), np.radians(86), np.pi/2],
                                  labels=[r"$0^\degree$",
                                          r"$45^\degree$",
                                          r"$60^\degree$",
                                          r"$75^\degree$",
                                          r"",
                                          r"$90^\degree$"])
    axs["combination"].set_yticks([1.25, 2.5], labels=["1.25", "2.5"])
    axs["combination"].set_title("Relative weight map")


    if shav:
        # Plot light model
        axs["sl"].plot(elevations,
                       shav_ls,
                       color="tab:olive",
                       linewidth=2)
        axs["sl"].set_xlim([-0.02, np.pi/2 + 0.02])
        axs["sl"].set_ylim([-0.01, 6.1])
        axs["sl"].set_yticks(np.arange(0,7,1), labels=[str(x) for x in np.arange(0,7,1)])
        axs["sl"].set_xticks([0, np.pi/2], labels=[r"$0^\degree$", r"$90^\degree$"])
        axs["sl"].set_xlabel(r"Light elevation - $\phi$")
        axs["sl"].set_ylabel(r"$\kappa$-estimation")
        axs["sl"].set_title("Light reliability model")

        # Plot wind model
        axs["sw"].plot(speeds,
                       shav_ws,
                       color="tab:cyan",
                       linewidth=2
        )
        axs["sw"].set_xlim([1.23, 2.52])
        axs["sw"].set_ylim([-0.01, 6.1])
        axs["sw"].set_yticks(np.arange(0,7,1), labels=[str(x) for x in np.arange(0,7,1)])
        axs["sw"].set_xticks([1.25, 2.5], labels=["1.25", "2.5"])
        axs["sw"].set_xlabel(r"Wind speed (m/s) - $s$")
        axs["sw"].set_ylabel(r"$\kappa$-estimation")
        axs["sw"].set_title("Wind reliability model")


        # Plot combination
        wmap = axs["sc"].pcolormesh(
            es, ss, shav_zs, vmax=1, vmin=0, cmap="BrBG_r")
        wmap.set_edgecolor('face')
        #fig.colorbar(wmap, ax=axs["sc"])
        axs["sc"].set_xlabel("Light elevation - $\phi$")
        axs["sc"].set_ylabel("Wind speed (m/s)")
        axs["sc"].set_xticks([0, np.pi/4, np.radians(60), np.radians(75), np.radians(86), np.pi/2],
                                      labels=[r"$0^\degree$",
                                              r"$45^\degree$",
                                              r"$60^\degree$",
                                              r"$75^\degree$",
                                              r"",
                                              r"$90^\degree$"])
        axs["sc"].set_yticks([1.25, 2.5], labels=["1.25", "2.5"])
        axs["sc"].set_title("Relative weight map")


        # Make pretty
        # Remove axes tick labels and axes labels from upper plots
        axs["light"].set_xlabel("")
        axs["combination"].set_xlabel("")
        axs["wind"].set_xlabel("")

        axs["light"].set_xticklabels([])
        axs["combination"].set_xticklabels([])
        axs["wind"].set_xticklabels([])


        axs["light"].text(0, 0.01, "Our model", ha="left", va="bottom")
        axs["sl"].text(0, 0.01, "Shaverdian et al. (2022)", ha="left", va="bottom")

    fig.tight_layout()
    filename = "plots/strength_model.pdf"
    fig.savefig(filename, bbox_inches="tight")
    # plt.show()
