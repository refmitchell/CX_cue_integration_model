"""
plot_conflict_shav.py

Produce circular scatter plots showing the change in bearing
between rolls three and four of the data generated by
conflict_shav.py.

Note that the same -s option can be specified here, in which
case the routine will load any data which was generated using
the adjusted reliability weighting model used by Shaverdian et
al. (2022) (assuming such data has been generated by running:

  $: python conflict_shav.py -s

"""
import argparse
import json
import numpy as np
import itertools
import matplotlib.pyplot as plt

import simulation_utilities as simutils
import dict_key_definitions as keydefs
import test_utilities as testutils
from dict_key_definitions import statskeys, simkeys, cwparamkeys
from dict_key_definitions import conflict_shav_reskeys as reskeys

# Import the dictionary of different experimental parameters.
from conflict_shav import generate_conditions

import sys

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-s",
                        "--shaverdian2022",
                        action="store_true",
                        required=False,
                        help="Plot kappa estimation from Shaverdian et al. (2022)")
    args = parser.parse_args()
    shav=args.shaverdian2022
    conditions, conflicts = generate_conditions()

    plotting_data = dict()
    plotting_data["1.25"] = dict()
    plotting_data["2.5"] = dict()

    wmspec = "swm" if shav else "pwm"
    print("info: using results for weight model: {}".format(wmspec))
    for exp in conditions:
        expstring = "{}-{}".format(exp[0], exp[1])
        print("Generating plot data for {}".format(expstring))

        # Load conflict orders
        with open("data_out/conflict_shav_{}_data_{}.json".format(wmspec,expstring)) as f:
            data = json.load(f)

        # Load stats data from file
        with open("data_out/conflict_shav_{}_stats_{}.json".format(wmspec,expstring)) as f:
            stats = json.load(f)

        # Load simulation metadata
        with open("data_out/conflict_shav_{}_meta_{}.json".format(wmspec,expstring)) as f:
            meta = json.load(f)


        #
        # Exclusion criterion
        #

        # Shaverdian et al. (2022) implement an exclusion criterion for
        # this experiment. They pool rolls where the cues were aligned and
        # verify that each individual was actually directed for those rolls.
        # We include the exclusion criterion here in order to match their
        # experimental protocol.

        keep = []
        for agent_idx in range(meta[simkeys.n]):
            exits = []
            # Compute mean of desired exits
            for key in reskeys.rollkeys():
                if key == reskeys.phase4 or key == reskeys.phase6:
                    continue # Skip conflict rolls
                exits += stats[key][statskeys.exit_angles][agent_idx]

            # Test exclusion criterion
            r, theta = testutils.circmean(exits)
            keep.append(testutils.rayleigh_crit(0.1, len(exits), r))

        # For each phase keep agents who were significantly oriented while
        # cues were aligned
        for key in reskeys.rollkeys():
            stats[key][statskeys.exit_angles] = list(
                np.array(stats[key][statskeys.exit_angles])[keep]
            )

        ######################################################################

        exits_five_deg = []
        for key in reskeys.rollkeys():
            exits = stats[key][statskeys.exit_angles]
            exits = list(itertools.chain(*exits))
            exits = np.radians(np.around(np.degrees(exits)/5, decimals=0)*5)
            exits_five_deg.append(exits)

        # Changes
        no_conflict_changes =  [
            testutils.angular_difference(x,y,signed=True)
            for (x,y) in zip(exits_five_deg[0], exits_five_deg[1])
        ]

        init_conflict_changes =  [
            testutils.angular_difference(x,y,signed=True)
            for (x,y) in zip(exits_five_deg[2], exits_five_deg[3])
        ]

        snd_conflict_changes =  [
            testutils.angular_difference(x,y,signed=True)
            for (x,y) in zip(exits_five_deg[4], exits_five_deg[5])
        ]

        # Determine which changes were 60deg and which were 120. Re-organise
        # changes by conflict rather than initial/secondary
        conflict_orders = data[reskeys.conflict_orders]
        initial_conflicts = [x[0] for x in conflict_orders]
        second_conflicts = [x[1] for x in conflict_orders]

        sixty_changes = [ change for (change,conf) in
                          zip(init_conflict_changes, initial_conflicts)
                          if conf == 60
        ]
        sixty_changes += [ change for (change,conf) in
                           zip(snd_conflict_changes, second_conflicts)
                           if conf == 60
        ]

        ot_changes = [ change for (change,conf) in
                       zip(init_conflict_changes, initial_conflicts)
                       if conf == 120
        ]
        ot_changes += [ change for (change,conf) in
                        zip(snd_conflict_changes, second_conflicts)
                        if conf == 120
        ]



        # This is a pretty awful construction, but I'd like to separate the plots
        # by windspeed.

        ws = str(exp[1])
        es = str(exp[0])

        plotting_data[ws][es] = dict()
        plotting_data[ws][es]["no_conf"] = dict()
        plotting_data[ws][es]["no_conf"]["changes"] = [x for x in no_conflict_changes if not np.isnan(x)]
        plotting_data[ws][es]["sixty"] = dict()
        plotting_data[ws][es]["sixty"]["changes"] = [x for x in sixty_changes if not np.isnan(x)]
        plotting_data[ws][es]["ot"] = dict()
        plotting_data[ws][es]["ot"]["changes"] = [x for x in ot_changes if not np.isnan(x)]

        for key in plotting_data[ws][es].keys():
            radial_base = 1

            plotting_data[ws][es][key]["changes"]

            # Polar scatter coordinates
            radii, scatter_angles = testutils.circ_scatter(
                plotting_data[ws][es][key]["changes"],
                radial_interval=-0.1,
                radial_base=radial_base
            )

            plotting_data[ws][es][key]["scatter_angles"] = scatter_angles
            plotting_data[ws][es][key]["radii"] = radii



            # Mean change
            mean = testutils.circmean(plotting_data[ws][es][key]["changes"])
            plotting_data[ws][es][key]["r"] = mean[0]
            plotting_data[ws][es][key]["mean_angle"] = mean[1]

            # Circular standard deviation (s0)
            plotting_data[ws][es][key]["circ_std_dev"] = testutils.angular_deviation(
                plotting_data[ws][es][key]["r"]
            )

            # 95% confidence interval
            plotting_data[ws][es][key]["ci95"] = testutils.confidence_interval(
                plotting_data[ws][es][key]["r"],
                0.05,
                len(plotting_data[ws][es][key]["changes"])
            )

            # 99% confidence interval
            # plotting_data[ws][es][key]["ci99"] = testutils.confidence_interval(
            #     plotting_data[ws][es][key]["r"],
            #     0.01,
            #     len(plotting_data[ws][es][key]["changes"])
            # )

    # Plots
    # 2.5m/s
    tf_mosaic = [["45-no_conf", "60-no_conf", "75-no_conf", "86-no_conf"],
                 ["45-sixty", "60-sixty", "75-sixty", "86-sixty"],
                 ["45-ot", "60-ot", "75-ot", "86-ot"]
    ]

    fig, axs = plt.subplot_mosaic(tf_mosaic,
                                  subplot_kw={"projection":"polar"},
                                  figsize=(12,8)
    )
    wmstring = "Shaverdian et al. (2022) weight model" if wmspec == "swm" else "Contrast (vector projection) model"
    fig.suptitle("2.5m/s wind speed - {}".format(wmstring))
    ws = "2.5"
    for axkey in axs.keys():
        ax = axs[axkey]
        es = axkey.split("-")[0]
        cs = axkey.split("-")[1]

        pd = plotting_data[ws][es][cs]

        ax.scatter(pd["scatter_angles"],
                   pd["radii"],
                   edgecolors='k',
                   s=10)


        included_n = len(pd["scatter_angles"])
        significance_colour = 'k' if testutils.rayleigh_crit(0.05, 30, pd["r"]) else 'tab:red'
        mean_line_rs = np.linspace(0,1.1,2)
        ax.plot(np.zeros(len(mean_line_rs)) + pd["mean_angle"],
                mean_line_rs,
                color=significance_colour,
                zorder=0)

        ax.text(0,
                0,
                "$\mu$ = {:.2f}$^\degree$\n$s0$ = {:.2f}$^\degree$\n$n$ = {}"
                .format(np.degrees(pd["mean_angle"]),
                        np.degrees(pd["circ_std_dev"]),
                        included_n
                ),
                ha="center",
                va="center",
                bbox=dict(facecolor='1', edgecolor=significance_colour, pad=1.5)
        )

        lo95 = pd["mean_angle"] - pd["ci95"]
        hi95 = pd["mean_angle"] + pd["ci95"]
        csd_arc = np.linspace(lo95, hi95, 100)
        ax.plot(csd_arc, np.zeros(len(csd_arc)) + 1.1, color=significance_colour)

        ax.set_theta_direction(-1)
        ax.set_theta_zero_location("N")
        cut_labels =  ["0$^\degree$",
                       "90$^\degree$",
                       "180$^\degree$",
                       ""]
        full_labels = ["0$^\degree$",
                       "90$^\degree$",
                       "180$^\degree$",
                       "-90$^\degree$"]
        labels = cut_labels if es == "45" else full_labels
        ax.set_xticks([0,np.pi/2, np.pi, 3*np.pi/2],
                      labels=labels,
                      fontsize=14)
        ax.set_ylim([0,radial_base + 0.15])
        ax.set_yticks([])

        if cs == "no_conf":
            ax.set_title("{}$^\degree$ elevation".format(es))

        if es == "45":
            intconf = 0
            if cs == "sixty":
                intconf = 60
            elif cs == "ot":
                intconf = 120

            ax.set_ylabel("{}$^\degree$ conflict".format(intconf))

    fig.tight_layout()
    fig.savefig("plots/conf_shav_{}_2-5.pdf".format(wmspec), bbox_inches="tight")

    # 1.25m/s
    tf_mosaic = [["60-no_conf", "75-no_conf", "86-no_conf"],
                 ["60-sixty", "75-sixty", "86-sixty"],
                 ["60-ot", "75-ot", "86-ot"]
    ]

    fig, axs = plt.subplot_mosaic(tf_mosaic,
                                  subplot_kw={"projection":"polar"},
                                  figsize=(12,8)
    )


    fig.suptitle("1.25m/s wind speed - {}".format(wmstring))
    ws = "1.25"
    for axkey in axs.keys():
        ax = axs[axkey]
        es = axkey.split("-")[0]
        cs = axkey.split("-")[1]

        pd = plotting_data[ws][es][cs]

        ax.scatter(pd["scatter_angles"],
                   pd["radii"],
                   edgecolors='k',
                   s=10)

        mean_line_rs = np.linspace(0,1.1,2)
        ax.plot(np.zeros(len(mean_line_rs)) + pd["mean_angle"],
                mean_line_rs,
                color='k',
                zorder=0)

        included_n = len(pd["scatter_angles"])
        ax.text(0,
                0,
                "$\mu$ = {:.2f}$^\degree$\n$s0$ = {:.2f}$^\degree$\n$n$={}"
                .format(np.degrees(pd["mean_angle"]),
                        np.degrees(pd["circ_std_dev"]),
                        included_n
                ),
                ha="center",
                va="center",
                bbox=dict(facecolor='1', edgecolor='grey', pad=1.5)
        )

        lo95 = pd["mean_angle"] - pd["ci95"]
        hi95 = pd["mean_angle"] + pd["ci95"]
        csd_arc = np.linspace(lo95, hi95, 100)
        ax.plot(csd_arc, np.zeros(len(csd_arc)) + 1.1, color='k')

        ax.set_theta_direction(-1)
        ax.set_theta_zero_location("N")

        cut_labels =  ["0$^\degree$",
                       "90$^\degree$",
                       "180$^\degree$",
                       ""]
        full_labels = ["0$^\degree$",
                       "90$^\degree$",
                       "180$^\degree$",
                       "-90$^\degree$"]
        labels = cut_labels if es == "60" else full_labels

        ax.set_xticks([0,np.pi/2, np.pi, 3*np.pi/2],
                      labels=labels,
                      fontsize=14)
        ax.set_ylim([0,radial_base + 0.15])
        ax.set_yticks([])

        if cs == "no_conf":
            ax.set_title("{}$^\degree$ elevation".format(es))

        if es == "60":
            intconf = 0
            if cs == "sixty":
                intconf = 60
            elif cs == "ot":
                intconf = 120

            ax.set_ylabel("{}$^\degree$ conflict".format(intconf))

    fig.tight_layout()
    fig.savefig("plots/conf_shav_{}_1-25.pdf".format(wmspec), bbox_inches="tight")
    # plt.show()
