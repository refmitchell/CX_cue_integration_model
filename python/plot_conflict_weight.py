"""
plot_conflict_weight.py

Produce circular scatter plots showing the change in bearing
between rolls three and four of the data generated by
conflict_weight.py.
"""
import json
import numpy as np
import itertools
import matplotlib.pyplot as plt

from test_utilities import circ_scatter, k, circmean
import dict_key_definitions as keydefs
from dict_key_definitions import statskeys, simkeys, cwparamkeys
from dict_key_definitions import conflict_weight_reskeys as reskeys

# Import the dictionary of different experimental parameters.
from conflict_weight import exp_params

def model_prediction(k1,k2,cue_one,cue_two):
    w1 = k1 / (k1 + k2)
    w2 = k2 / (k1 + k2)
    c1 = np.radians(cue_one)
    c2 = np.radians(cue_two)

    xs = [w1*np.cos(c1), w2*np.cos(c2)]
    ys = [w1*np.sin(c1), w2*np.sin(c2)]
    x = sum(xs)
    y = sum(ys)

    r = np.sqrt(x**2 + y**2)
    t = np.arctan2(y,x)

    return (r,t)

if __name__ == "__main__":
    titles = dict()
    titles[cwparamkeys.vary_strength] = "A) Equal reliability,\n different weight"
    titles[cwparamkeys.vary_reliability] = "B) Equal weight,\n different reliabilities"
    titles[cwparamkeys.vary_both_inv] = "C) Relative weight inverse\n of relative reliability"


    mosaic = [[cwparamkeys.vary_strength,
               cwparamkeys.vary_reliability,
               cwparamkeys.vary_both_inv]]
    omitted = [cwparamkeys.vary_both,
               cwparamkeys.all_equal_k2,
               cwparamkeys.all_equal_k4]

    # vary_both, and both 'all_equal' conditions were removed in the
    # final figure. This mosaic is left so you can plot those conditions if you'd
    # like. These conditions were omitted for clarity.

    # Uncomment this block to plot all influence mechanics data!
    # titles[cwparamkeys.vary_both] = "D) Relative weight matches relative reliability"    
    # titles[cwparamkeys.all_equal_k2] = "E) Equal weight, equal reliability ($\kappa$ = 2)"
    # titles[cwparamkeys.all_equal_k4] = "F) Equal weight, equal reliability ($\kappa$ = 4)"
    # mosaic = [[cwparamkeys.vary_strength,
    #            cwparamkeys.vary_reliability,
    #            cwparamkeys.vary_both_inv],
    #            [cwparamkeys.vary_both,
    #            cwparamkeys.all_equal_k2,
    #            cwparamkeys.all_equal_k4]]
    # omitted = []


    fig, axs = plt.subplot_mosaic(mosaic,
                                  figsize=(8,4),
                                  subplot_kw={"projection":"polar"})

    fig.tight_layout()

    for exp in exp_params.keys():
        if exp in omitted:
            continue
        print("Generating plot for {}".format(exp))
        # Load stats data from file
        with open("data_out/conflict_weight_{}_stats.json".format(exp)) as f:
            stats = json.load(f)

        # Load simulation metadata
        with open("data_out/conflict_weight_{}_meta.json".format(exp)) as f:
            meta = json.load(f)

        # Naming here isn't ideal. phase2 is the pre-conflict (third) roll
        # for this experiment
        roll_three_exits = stats[reskeys.phase2][statskeys.exit_angles]
        roll_three_exits = list(itertools.chain(*roll_three_exits))
        roll_three_exits = np.radians(
            np.around(np.degrees(roll_three_exits)/5, decimals=0)*5
        )

        # Phase 3 is the conflict roll.
        roll_four_exits = stats[reskeys.phase3][statskeys.exit_angles]
        roll_four_exits = list(itertools.chain(*roll_four_exits))
        roll_four_exits = np.radians(
            np.around(np.degrees(roll_four_exits)/5, decimals=0)*5
        )

        changes = (roll_four_exits - roll_three_exits)
        mean = circmean(changes)

        changes_rs, changes_ts = circ_scatter(changes, radial_interval=-0.1)

        unique, counts = np.unique(changes, return_counts=True)

        # Work out rough predicted mean
        c1 = 0
        c2 = 120
        k1 = exp_params[exp][0]
        k2 = exp_params[exp][1]
        w1 = exp_params[exp][2]
        w2 = exp_params[exp][3]

        k_equal = 4
        r,t = model_prediction(w1, w2, c1, c2)
        r1,t1 = model_prediction(k1, k2, c1, c2)
        rayleigh_k = k(0.05, meta[simkeys.n])
        rayleigh_k = np.sqrt(rayleigh_k/meta[simkeys.n])

        # exp_params uses cwparamkeys on initialisation so this should match
        axs[exp].set_title(titles[exp])
        axs[exp].scatter(changes_ts, changes_rs, alpha=0.8, c='k', s=10,zorder=3, label="individual change")
        axs[exp].set_theta_direction(-1)
        axs[exp].set_theta_zero_location("N")
        axs[exp].arrow(0, 0, mean[1],mean[0], color='k', label="population mean",zorder=5)
        axs[exp].arrow(0, 0, t, r, color='seagreen',
                  label="amplitude alone"
                  .format(k_equal, alpha = 0.5)
        )
        axs[exp].arrow(0, 0, t1, r1, color='darkorchid', label="reliability alone",
                       alpha=0.5)
        axs[exp].set_ylim([0,1.1])
        axs[exp].set_xticks([0, np.pi/2, np.pi, 3*np.pi/2])
        axs[exp].set_xticklabels(["$0^\degree$",
                                  "$90^\degree$",
                                  "$180^\degree$",
                                  "$-90^\degree$"])
        axs[exp].set_yticks([])

        # Plot criticality ring for p <= 0.05
        axs[exp].plot(np.linspace(0,2*np.pi,1000),
                      np.zeros(1000)+rayleigh_k,
                      linestyle="--",
                      color='k'
        )

        axs[exp].scatter(0,
                         1.2,
                         c="#fc9879",
                         edgecolor="#f85f43",
                         clip_on=False,
                         label="cue one")
        axs[exp].scatter(np.radians(120),
                         1.2,
                         c="#99c7e0",
                         edgecolor="#5ba3d0",
                         clip_on=False,
                         label="cue two")

        if exp == cwparamkeys.vary_both_inv:
            axs[exp].legend(ncols=6,
                       prop={'size':8},
                       loc=10,
                       bbox_to_anchor=(0.5, 0.15),
                       bbox_transform=fig.transFigure)

    fig.savefig("plots/conflict_weight.svg", bbox_inches="tight")
